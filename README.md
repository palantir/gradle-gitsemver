Semantic Versioning / Gitflow Gradle Plugin
===========================================

Purpose
----------------

This gradle plugin automatically sets the version of your project in git repos that use the gitflow model. It uses tags as its primary source of version information. Please use version 0.2.0 or later of the Palantir Gitflow tool with this library.

How do I use it?
-----------------

### Applying the plugin

* Add a dependency on this plugin in your build.gradle buildscript section
* apply plugin: "semver-gitflow"
* This will add a task called 'printVersion' that prints out the version generated by the plugin

### Semantic Versioning Primer

* Semantic versions look like: Major.Minor.Patch(-Optional.Release.Info)?(+Optional.Metadata)?
* Versions are compared based on the major, minor, patch, and release info sections

### Tag Based Versioning

* The version is based on the latest tag (highest via Semantic Version comaparison) tag that could be found
* This tag should be composed of three numbers with an optional dash and modifier and optionally prependeded with a 'v'. Examples:
    * v1.0.0
    * 1.0.0
    * v1.0.0-dev
    * v1.1.0-rc
    * v1.1.1-hotfix
    * v1.1.2-support.someCustomer

### Stable Tags

* A commit is considered stable if
    * It is tagged with a stable version number
* The versions produced will be the same as the numbers in the tag. Example:
    * Tag: v1.0.0
    * Version: 1.0.0

### Unstable Tags

* In every other situation, the version is calculated by taking the tag name (w/o the prepended 'v'), adding the count of commits since that tag, and adding the head commit id, and optionally build number metadata
* If you pass the a build number (must be a number) as the environment variable BUILD_NUMBER it will be used as a build number for version metadata.
* Example
    * Tag: v1.0.0-dev, num of commits: 4, commit id: s5fd4y6, build number: 123
    * Version: 1.0.0-dev.4+gs5fd4y6.b123

### Dirty Repo

* If your repo is in a dirty state when you run the build, the version will be postpended by ".dirty". This includes stable tag builds. When the repo is dirty, there is no solid concept of versioning.

### Using Gitflow

* In order to use this plugin, gitflow should be used with the following extensions:
    - When you do git flow init -d, also make an empty commit on develop and tag it "v0.0.0-dev"
    - When you create a release branch, create an empty commit on that branch and tag it "vRelVer-rc"
    - When you create a hotfix branch, create an empty commit on that branch and tag it "vHotfixVer-hotfix"
    - When you create a support branch, create an empty commit on that branch and tag it "vSupportVer-support(.customerName)?"
    - When you finish a release branch, tag the merge commit on develop "vRelVer-dev"
    - When you finish a hotfix branch, tag the merge commit on develop "vHotfixVer-dev"

### Publishing to an Artifact Repository

* Only publish the results of builds on the develop, release, hotfix, support, and master branches to an artifact repository


Java Semantic Versioning Implementation
=======================================

Purpose
----------------

This is meant to be a canonical java implementation of Palantir semantic version parsing and comparison.

How do I use it?
-----------------

### Validation

```
SemanticVersions.isValid(myVersionString);
```


### Parse and compare

```
SemanticVersion versionOne = SemanticVersions.parse(versionOneString);
SemanticVersion versionTwo = SemanticVersions.parse(versionTwoString);
int comparisonResult = versionOne.compareTo(versionTwo);
if (comparisonResult < 0) {
    // versionOne is the older version
} else if (comparisonResult > 0) {
    // versionTwo is the older version
} else {
    // versionOne and versionTwo are the same version
}
```